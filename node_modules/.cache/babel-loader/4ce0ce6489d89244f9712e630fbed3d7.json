{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/jpa/Desktop/goAlgo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";export default function dijkstra(grid,startNode,endNode){var visitedNodesInOrder=[];startNode.distance=0;var unvisitedNodes=getAllNodes(grid);while(unvisitedNodes.length>0){sortNodesByDistance(unvisitedNodes);var nearestNode=unvisitedNodes.shift();nearestNode.isVisited=true;if(nearestNode.isWall)continue;if(nearestNode===endNode||nearestNode.distance===Infinity){visitedNodesInOrder.shift();return visitedNodesInOrder;}updateUnvisitedNeighbors(nearestNode,grid);visitedNodesInOrder.push(nearestNode);}}function sortNodesByDistance(unvisitedNodes){unvisitedNodes.sort(function(nodeOne,nodeTwo){return nodeOne.distance-nodeTwo.distance;});}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);// \"top\"\nif(col<grid[0].length-1)neighbors.push(grid[row][col+1]);// \"right\"\nif(row<grid.length-1)neighbors.push(grid[row+1][col]);// \"bottom\"\nif(col>0)neighbors.push(grid[row][col-1]);// \"left\"\nreturn neighbors.filter(function(neighbor){return!neighbor.isVisited&&!neighbor.isWall;});}function updateUnvisitedNeighbors(node,grid){var neighbors=getUnvisitedNeighbors(node,grid);var _iterator=_createForOfIteratorHelper(neighbors),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;neighbor.distance=node.distance+1;neighbor.previousNode=node;}}catch(err){_iterator.e(err);}finally{_iterator.f();}}function getAllNodes(grid){var nodes=[];var _iterator2=_createForOfIteratorHelper(grid),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var row=_step2.value;var _iterator3=_createForOfIteratorHelper(row),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var node=_step3.value;nodes.push(node);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return nodes;}export function getNodesInShortestPath(finishNode){var shortestPath=[];var currentNode=finishNode;while(currentNode!==null){shortestPath.unshift(currentNode);currentNode=currentNode.previousNode;}return shortestPath;}","map":{"version":3,"sources":["/Users/jpa/Desktop/goAlgo/src/PathfindingViz/dijkstra.js"],"names":["dijkstra","grid","startNode","endNode","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","nearestNode","shift","isVisited","isWall","Infinity","updateUnvisitedNeighbors","push","sort","nodeOne","nodeTwo","getUnvisitedNeighbors","node","neighbors","col","row","filter","neighbor","previousNode","nodes","getNodesInShortestPath","finishNode","shortestPath","currentNode","unshift"],"mappings":"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","sourcesContent":["export default function dijkstra(grid, startNode, endNode) {\n\n  const visitedNodesInOrder = [];\n\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (unvisitedNodes.length > 0) {\n    sortNodesByDistance(unvisitedNodes)\n    const nearestNode = unvisitedNodes.shift();\n    nearestNode.isVisited = true;\n    if (nearestNode.isWall) continue;\n    if (nearestNode === endNode || nearestNode.distance === Infinity) {\n      visitedNodesInOrder.shift();\n      return visitedNodesInOrder;\n    }\n    updateUnvisitedNeighbors(nearestNode, grid);\n    visitedNodesInOrder.push(nearestNode);\n  }\n\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeOne, nodeTwo) => nodeOne.distance - nodeTwo.distance);\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]); // \"top\"\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]) // \"right\"\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]); // \"bottom\"\n  if (col > 0) neighbors.push(grid[row][col - 1]) // \"left\"\n  return neighbors.filter(neighbor => !neighbor.isVisited && !neighbor.isWall);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const neighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of neighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nexport function getNodesInShortestPath(finishNode) {\n  const shortestPath = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    shortestPath.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return shortestPath;\n}\n"]},"metadata":{},"sourceType":"module"}